---
alwaysApply: true
---
# Expo React Native Rule (Low-Income + SQLite)

You are a coding agent working in this repository. This project MUST use **Expo**.

## HARD REQUIREMENTS

## 1) Expo-first setup (mandatory)
- This app MUST be built and run with **Expo**.
- Prefer Expo SDK modules over bare React Native native modules.
- Avoid adding custom native code unless absolutely necessary.
- If any change requires native projects, use Expo’s managed workflow defaults, and only use `expo prebuild` when explicitly needed.

## 2) Dependencies / libraries
- You MAY use any library/package/API when it meaningfully improves the solution.
- If you introduce anything new, you MUST:
  - Explain why it’s needed.
  - Provide exact install commands (prefer `npx expo install ...` for Expo-supported packages).
  - Note any extra configuration (app.json/app.config.js, plugins, permissions).
  - Keep dependencies minimal, stable, and widely maintained.
  - Prefer libraries that support **React Native + Expo + React Native Web**.
- Avoid heavy dependencies that increase bundle size or slow low-end devices.
- Everything used should be free
-Don't depend on me giving you prompts on what libraries/API/packages to use, if needed, get one yourself

## 3) Design / UI (clean, effective, non-“AI”)
- Keep design clean, simple, and effective.
- Avoid “obvious AI” design tropes:
  - NO gradients, glassmorphism, neon glows, excessive shadows, busy backgrounds, over-rounded components.
- Prefer neutral colors, clear spacing, readable typography, and functional UI.
- Accessibility is required: contrast, touch targets, labels, and keyboard navigation on web when applicable.

## 4) Low-income / low-connectivity constraints (e.g., Sudan)
Assume:
- Intermittent connectivity, expensive/limited data, older/low-RAM phones, power instability.

Therefore:
- **Offline-first by default**: core flows must work with no network.
- Minimize network usage:
  - Avoid polling; batch requests; debounce user-triggered calls; prefer incremental sync.
- Local-first reads/writes:
  - Persist data locally and sync when online.
- Performance matters:
  - Avoid heavy animations; keep screens lightweight; use FlatList virtualization; memoize expensive renders.
- Bundle and asset discipline:
  - Avoid large images/fonts; compress assets; lazy-load when possible.
- Resilient UX:
  - Clear offline/online states, retries, conflict-safe updates, and error messages users can act on.

## 5) Database: SQLite (mandatory via Expo)
- Use **SQLite** for local persistence.
- The default database implementation MUST be **`expo-sqlite`**.
- Implement a DB layer that:
  - Lives in `src/db/` (or similar) and is isolated from UI.
  - Provides schema initialization and migrations.
  - Uses async patterns (avoid blocking UI thread where possible).
  - Has safe error handling and basic retry strategy for transient failures.
  - Uses indexes for frequently queried fields.
- Web compatibility:
  - If the SQLite library behavior differs on web, you MUST provide a consistent abstraction so the rest of the app is platform-agnostic.
  - Prefer maintaining the same query API across platforms.

## 6) Cross-platform compatibility (Expo + Web + Android)
- Everything must run on:
  - **Expo Go** (dev)
  - **Android emulator/device**
  - **Web** via Expo’s web support
- Use React Native primitives (`View`, `Text`, `Pressable`, etc.).
- Avoid DOM APIs unless strictly gated and optional.
- Any platform-specific logic must use `Platform.select` and safe fallbacks.
- Avoid libraries that are “native-only” without web support unless abstracted and not required for web.

## 7) Git hygiene
- If a suitable `.gitignore` does not exist, create one.
- Ensure it covers:
  - `node_modules`, logs, `.env*` secrets
  - Expo artifacts (`.expo/`, `.expo-shared/`)
  - Web build output (`web-build/`)
  - Native build output if prebuild is used (`android/`, `ios/` build folders)
  - IDE folders

## 8) Local testing environment (Web + Android + APK)
Every feature must include clear local run steps.

### Required scripts/commands to support
- Web dev:
  - `npx expo start --web`
- Android dev:
  - `npx expo start --android`
- Debug APK build (local, using prebuild + Gradle):
  - `npx expo prebuild -p android` (only if needed)
  - `cd android && ./gradlew assembleDebug`
  - Result: `android/app/build/outputs/apk/debug/app-debug.apk`

### EAS Build (recommended for shareable APK)
- Support EAS Build flow:
  - `npm i -g eas-cli`
  - `eas login`
  - `eas build -p android --profile preview`
- If EAS profiles are added/changed, document them in `README.md`.

### Automated testing expectations
- Prefer cross-platform tests:
  - Unit tests: `jest` + `@testing-library/react-native`
  - Lint: ESLint
  - Format: Prettier
- If tests are added:
  - Add/adjust `package.json` scripts: `test`, `lint`, `format`
  - Provide exact run commands.

## WORKING STYLE
- Before coding:
  - State assumptions briefly.
  - List files you will add/change.
- Prefer simple, composable modules.
- Don’t overengineer: ship the smallest maintainable solution.
- Always account for offline-first constraints and low-end device performance.

## OUTPUT FORMAT
- New files: provide full file contents.
- Edits: provide concise diffs/excerpts and exact filenames/paths.
- Always end with:
  - how to run locally
  - how to test on web
  - how to test on Android
  - how to build and install a debug APK

### For the local testing environment part make sure you don't always make an apk or anything just setup everything for easy testing

## 9) Focus on implementing on the web first before optimizing for the app
- For all my prompts, I will be focusing on the web aspect. 
- Make sure to consider the app when making code for my prompts